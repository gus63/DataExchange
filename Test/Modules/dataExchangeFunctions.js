////	author: Leo Linbeck III//var CLASS_HEADER = '"__CLASS_HEADER__"';var PREVIEW_SIZE = 5;function buildAttributeMapJSON(obj) {	var attr, attrMap = [], className, i, importArray, importString, mapObject, quote = '"';		obj.data.forEach(		function (dataObject) {			className = dataObject.className;			entityKeys = Object.keys(dataObject.entities[0])			entityKeys.forEach(				function (attr) {					if (attr !== '__KEY') {						mapObject = {};						mapObject.fromAttr = className + '.' + attr;						if(ds[className][attr].kind === 'relatedEntity') {							mapObject.fromAttr += '.ID';						}						mapObject.toAttr = findMatchingAttribute(className, attr);						attrMap.push(mapObject);					}				}			);		}	);		return attrMap;}function verifyJSONImportFile(importFile) {	var headers = [], importString, result, stream, version = [];		stream = TextStream(importFile, 'read');	importString = stream.read();	stream.close();	importObject = JSON.parse(importString);	if (importObject.header !== undefined) {		if (importObject.header.version === '1.0') {			result = {				success: true,				code: 'verifyImportSuccessful',				message: 'Verify successful for import file:<br/>' + importFile.name,				attributeMap: buildAttributeMapJSON(importObject)			};		}		else {			result = {				success: false,				code: 'invalidImportVersion',				message: 'Wrong version (' + importObject.header.version + ') for file:<br/>' + importFile.name			}		}	}	else {		result = {			success: false,			code: 'invalidHeaderFormat',			message: 'Invalid header format for import file:<br/>' + importFile.name		}	}		return result;}function findMatchingAttribute(className, attrName) {	var attrArray, relatedClass, result = '';		if (attrName.indexOf('.') === -1) {		if (ds[className] !== undefined && ds[className][attrName] !== undefined) {			if (attrName !== '__KEY' && ds[className][attrName].kind === 'storage') {				result = className + '.' + attrName;			}			if (ds[className][attrName].kind === 'relatedEntity') {				result = className + '.' + attrName + '.ID';			}		}	}	else {		attrArray = attrName.split('.');		relatedClass = ds[className][attrArray[0]].type;		if (ds[relatedClass] !== undefined && ds[relatedClass][attrArray[1]] !== undefined) {			if (ds[relatedClass][attrArray[1]].kind === 'storage') {				result = className + '.' + attrArray[0] + '.' + attrArray[1];			}		}	}		return result;}function buildAttributeMapText(stream, delim) {	var attr, attrMap = [], className, i, importArray, importString, mapObject, quote = '"';		importString = stream.read('\n');	while (importString !== '') {		importArray = importString.split(quote + delim + quote);		if ((importArray[0] + quote) === CLASS_HEADER) {			className = importArray[1];			for (i = 2; i < importArray.length; i += 1) {				mapObject = {};				attr = importArray[i];				if (i === (importArray.length - 1)) {					attr = attr.substr(0, attr.length - 2);				}				mapObject.fromAttr = className + '.' + attr;				mapObject.toAttr = findMatchingAttribute(className, attr);				attrMap.push(mapObject);			}		}		importString = stream.read('\n');	}		return attrMap;}function verifyTextImportFile(importFile, delim) {	var headers = [], importString, result, stream, version = [];		stream = TextStream(importFile, 'read');	importString = stream.read('\n');	headers = importString.split(',');	if (headers.length === 2) {		version = headers[0].split(':');		if (version[1] === '1.0') {			result = {				success: true,				code: 'verifyImportSuccessful',				message: 'Verify successful for import file:<br/>' + importFile.name,				attributeMap: buildAttributeMapText(stream, delim)			};		}		else {			result = {				success: false,				code: 'invalidImportVersion',				message: 'Wrong version (' + version[1] + ') for file:<br/>' + importFile.name			}		}	}	else {		result = {			success: false,			code: 'invalidHeaderFormat',			message: 'Invalid header format for import file:<br/>' + importFile.name		}	}		stream.close();	return result;}function verifyImportFile(fileFormat, filename, importFolder) {	var importFile, result;	filename += '.' + fileFormat;	if (File.isFile(importFolder.path + filename)) {		importFile = File(importFolder.path + filename);		switch (fileFormat) {			case 'json':				result = verifyJSONImportFile(importFile);				break;			case 'csv':				result = verifyTextImportFile(importFile, ',');				break;			case 'txt':				result = verifyTextImportFile(importFile, '\t');				break;			default:				result = {					success: false,					code: 'invalidFileFormat',					message: 'Verify failed: unknown file format:<br/>' + fileFormat				};				break;		}	}	else {		result = {			success: false,			code: 'cannotFindImportFile',			message: 'Unable to find file:<br/>' + filename		};	}		return result;}function remapAttributeMap(attributeMap) {	var newMap = {};		attributeMap.forEach(		function (a) {			var arr = a.toAttr.split('.');			newMap[a.fromAttr] = arr;		}	);		return newMap;}function conjureEntityText (className, attrArray, valueArray, attrMap) {	var attrCount, attrKey, conjuredEntity, dataClass, keyAttr, primaryKey, targetAttr, success = true;		dataClass = ds[className];	keyAttr = 'ID';	primaryKey = valueArray[attrArray.indexOf(keyAttr)];	conjuredEntity = dataClass(primaryKey);	if (conjuredEntity === null) {		conjuredEntity = dataClass.createEntity();		conjuredEntity.ID = primaryKey;	}		attrCount = 0;	attrArray.forEach(		function (attr) {			if (success && attr !== keyAttr) {				targetAttr = attrMap[className + '.' + attr];				if (targetAttr[0] === dataClass) {					switch (target.length) {						case 2:							conjuredEntity[targetAttr[1]] = valueArray[attrCount];							attrCount += 1;							break;						case 3:							conjuredEntity[targetAttr[1]][targetAttr[2]] = valueArray[attrCount];							attrCount += 1;							break;						default:							success = false;					}				}				else {					success = false;				}			}		}	);		if (success) {		try {			conjuredEntity.save();		} catch (e) {			success = false;		}	}		return success;}function importAllEntitiesText(attrMap, stream, delim)  {	var attrArray, importArray, importString, numberOfEntities = 0, quote = '"';		importString = stream.read('\n');	while (importString !== '') {		importArray = importString.split(quote + delim + quote);		if ((importArray[0] + quote) === CLASS_HEADER) {			className = importArray[1];			attrArray = importArray.slice(2);			importString = stream.read('\n');			importArray = importString.split(quote + delim + quote);		}		importArray[0] = importArray[0].slice(1);		importArray[importArray.length - 1] = importArray[importArray.length - 1].slice(0, importArray.length - 1);		if (conjureEntityText(className, attrArray, importArray, attrMap)) {			numberOfEntities += 1;			importString = stream.read('\n');		}		else {			throw (numberOfEntities);		}	}		return numberOfEntities;}function executeTextImportFile(attributeMap, importFile, delim) {	var attrMap, headers = [], importString, result, stream, version = [];		attrMap = remapAttributeMap(attributeMap);	stream = TextStream(importFile, 'read');	importString = stream.read('\n');	headers = importString.split(',');	if (headers.length === 2) {		version = headers[0].split(':');		if (version[1] === '1.0') {			try {				numberOfEntities = importAllEntitiesText(attrMap, stream, delim);				result = {					success: true,					code: 'executeImportSuccessful',					message: 'Import successful for file:<br/>' + importFile.name,					numberOfEntities: numberOfEntities				};			} catch (e) {				result = {					success: false,					code: 'importFailed',					message: 'Import failed for file:<br/>' + importFile.name,					numberOfEntities: e				};			}		}		else {			result = {				success: false,				code: 'invalidImportVersion',				message: 'Wrong version (' + version[1] + ') for file:<br/>' + importFile.name			}		}	}	else {		result = {			success: false,			code: 'invalidHeaderFormat',			message: 'Invalid header format for import file:<br/>' + importFile.name		}	}		stream.close();	return result;}function executeImportFile(param, importFolder) {	var filename, importFile, result;	filename = param.filename + '.' + param.format;	if (File.isFile(importFolder.path + filename)) {		importFile = File(importFolder.path + filename);		switch (param.format) {			case 'json':				result = executeJSONImportFile(param.attributeMap, importFile);				break;			case 'csv':				result = executeTextImportFile(param.attributeMap, importFile, ',');				break;			case 'txt':				result = executeTextImportFile(param.attributeMap, importFile, '\t');				break;			default:				result = {					success: false,					code: 'invalidFileFormat',					message: 'Import failed: unknown file format:<br/>' + fileFormat				};				break;		}	}	else {		result = {			success: false,			code: 'cannotFindImportFile',			message: 'Unable to find file:<br/>' + filename		};	}		return result;}function importVerifyFunction(param) {	var importFolder, result;	importFolder = Folder(ds.getModelFolder().path + 'ExportData');	if (importFolder.create()) {		result = verifyImportFile(param.format, param.filename, importFolder);	}	else {		result = {			success: false,			code: 'cannotCreateExportFolder',			message: 'Unable to find folder for export data'		};	}		return result;};function importExecuteFunction(param) {	var importFolder, result;	importFolder = Folder(ds.getModelFolder().path + 'ExportData');	if (importFolder.create()) {		result = executeImportFile(param, importFolder);	}	else {		result = {			success: false,			code: 'cannotCreateExportFolder',			message: 'Unable to find folder for export data'		};	}		return result;};function exportPreviewFunction(param) {	var resultString;		switch (param.format) {		case 'json':			resultString = exportJSONPreview(param);			break;					case 'csv':			resultString = exportCSVPreview(param);			break;				case 'txt':			resultString = exportTextPreview(param);			break;	}		return (resultString);}function exportClassesFunction(param) {	var resultObject;		switch (param.format) {		case 'json':			resultObject = exportJSON(param);			break;					case 'csv':			resultObject = exportCSV(param);			break;				case 'txt':			resultObject = exportText(param);			break;	}		return (resultObject);}function getJSONHeader(param) {	var header = {};		header.version = '1.0';	header.classes = param.classes;	header.format = param.format;	header.attr = {};	param.classes.forEach(		function (className) {			if (header.attr[className] === undefined) {				header.attr[className] = [];			}			for (attr in ds[className].attributes) {				header.attr[className].push(attr);			}		}	);		return header;}function getJSONClass(className, preview) {	var dataClass = ds[className];		return {		className: className, 		entities: dataClass.toArray('', '', true, 0, preview ? PREVIEW_SIZE : dataClass.length)	};}function getHeaderString(className, delim) {	var attr, dataClass, quote = '"', s;		s = CLASS_HEADER + delim + quote + className + quote + delim;	dataClass = ds[className];	for (attr in dataClass.attributes) {		if (dataClass[attr].kind === 'storage') {			s +=  quote + attr + quote + delim;		}		if (dataClass[attr].kind === 'relatedEntity') {			s +=  quote + attr + '.ID' + quote + delim;		}		if (dataClass[attr].kind === 'alias') {			s +=  quote + attr + quote + delim;		}	}		return (s.substr(0,s.length - 1) + '\n');}function getEntityString(entity, delim) {	var attr, dataClass, quote = '"', s = '';		dataClass = entity.getDataClass();	for (attr in dataClass.attributes) {		if (dataClass[attr].kind === 'storage') {			s +=  quote + entity[attr].toString() + quote + delim;		}		if (dataClass[attr].kind === 'relatedEntity') {			s +=  quote + entity[attr].getKey().toString() + quote + delim;		}		if (dataClass[attr].kind === 'alias') {			s +=  quote + entity[attr].toString() + quote + delim;		}	}	return (s.substr(0, s.length - 1) + '\n');}function preparePreviewString(classNames, delim) {	var entities, i, r = '';	r = 'version:1.0' + delim + 'format:csv' + delim + 'classes:' + classNames.join('/') + '\n';	classNames.forEach(		function (className) {			r += getHeaderString(className, delim);			entities = ds[className].all();			for (i = 0; i < (entities.length < PREVIEW_SIZE ? entities.length : PREVIEW_SIZE); i += 1) {				r += getEntityString(entities[i], delim);			}		}	);		return r;}function prepareExportString(classNames, delim) {	var entities, i, r = '';	r = 'version:1.0,classes:' + classNames.join('/') + '\n';	classNames.forEach(		function (className) {			r += getHeaderString(className, delim);			entities = ds[className].all();			entities.forEach(				function (entity) {					r += getEntityString(entity, delim);				}			);		}	);		return r;}function exportJSONPreview(param) {	var result = {};		result.header = getJSONHeader(param);	result.data = [];	param.classes.forEach(		function (c) {			result.data.push(getJSONClass(c, true));		}	);		return JSON.stringify(result);}function exportCSVPreview(param) {	return preparePreviewString(param.classes, ',');}function exportTextPreview(param) {	return preparePreviewString(param.classes, '\t');}function exportStringToFile(exportString, filename, fileFormat) {	var exportFile, exportFolder, stream, result = {};	if (!filename) {		filename = generateUUID();	}	filename += '.' + fileFormat;		exportFolder = Folder(ds.getModelFolder().path + 'ExportData');	if (exportFolder.create()) {		exportFile = File(exportFolder.path + filename);		if (File.isFile(exportFolder.path + filename)) {			exportFile.remove();		}		if (exportFile.create()) {			stream = TextStream(exportFile, 'write');			stream.write(exportString);			stream.close();			result = {				success: true,				code: 'exportSuccessful',				message: exportString.length + ' bytes exported to:<br/>' + filename			};		}		else {			result = {				success: false,				code: 'cannotCreateExportFile',				message: 'Unable to create file:<br/>' + filename			};		}	}	else {		result = {			success: false,			code: 'cannotCreateExportFolder',			message: 'Unable to create folder for export data'		};	}		return result;}function exportJSON(param) {	var result = {};	result.header = getJSONHeader(param);	result.data = [];	param.classes.forEach(		function (c) {			result.data.push(getJSONClass(c));		}	);		return exportStringToFile(JSON.stringify(result), param.filename, param.format);}function exportCSV(param) {	var exportString;		exportString = prepareExportString(param.classes, ',');	return exportStringToFile(exportString, param.filename, param.format);}function exportText(param) {	var exportString;		exportString = prepareExportString(param.classes, '\t');	return exportStringToFile(exportString, param.filename, param.format);}