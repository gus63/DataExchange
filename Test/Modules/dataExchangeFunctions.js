////	author: Leo Linbeck III//var CLASS_HEADER = '__CLASS_HEADER__';var PREVIEW_SIZE = 5;function buildAttributeMapJSON(obj) {	var attr, attrMap = [], className, i, importArray, importString, mapObject, quote = '"';		obj.data.forEach(		function (dataObject) {			className = dataObject.className;			entityKeys = Object.keys(dataObject.entities[0])			entityKeys.forEach(				function (attr) {					if (attr !== '__KEY') {						mapObject = {};						mapObject.fromAttr = className + '.' + attr;						if(ds[className][attr].kind === 'relatedEntity') {							mapObject.fromAttr += '.ID';						}						mapObject.toAttr = findMatchingAttribute(className, attr);						mapObject.skip = (mapObject.toAttr === '');						attrMap.push(mapObject);					}				}			);		}	);		return attrMap;}function verifyJSONImportFile(importFile) {	var headers = [], importString, result, stream, version = [];		stream = TextStream(importFile, 'read');	importString = stream.read();	stream.close();	importObject = JSON.parse(importString);	if (importObject.header !== undefined) {		if (importObject.header.version === '1.0') {			result = {				success: true,				code: 'verifyImportSuccessful',				message: 'Verify successful for import file:<br/>' + importFile.name,				attributeMap: buildAttributeMapJSON(importObject)			};		}		else {			result = {				success: false,				code: 'invalidImportVersion',				message: 'Wrong version (' + importObject.header.version + ') for file:<br/>' + importFile.name			}		}	}	else {		result = {			success: false,			code: 'invalidHeaderFormat',			message: 'Invalid header format for import file:<br/>' + importFile.name		}	}		return result;}function findMatchingAttribute(className, attrName) {	var attrArray, relatedClass, result = '';		if (attrName.indexOf('.') === -1) {		if (ds[className] !== undefined && ds[className][attrName] !== undefined) {			if (attrName !== '__KEY' && ds[className][attrName].kind === 'storage') {				result = className + '.' + attrName;			}			if (ds[className][attrName].kind === 'relatedEntity') {				result = className + '.' + attrName + '.ID';			}		}	}	else {		attrArray = attrName.split('.');		relatedClass = ds[className][attrArray[0]].type;		if (ds[relatedClass] !== undefined && ds[relatedClass][attrArray[1]] !== undefined) {			if (ds[relatedClass][attrArray[1]].kind === 'storage') {				result = className + '.' + attrArray[0] + '.' + attrArray[1];			}		}	}		return result;}function importParse(importString, delim) {	var importArray, last, quote = '"';		importArray = importString.split(quote + delim + quote);	importArray[0] = importArray[0].slice(1);	last = importArray.length - 1;	importArray[last] = importArray[last].slice(0,importArray[last].length - 2);		return importArray;}function buildAttributeMapText(stream, delim) {	var attr, attrMap = [], className, i, importArray, importString, mapObject, quote = '"';		importString = stream.read('\n');	while (importString !== '') {		importArray = importParse(importString, delim);		if (importArray[0] === CLASS_HEADER) {			className = importArray[1];			for (i = 2; i < importArray.length; i += 1) {				attr = importArray[i];				mapObject = {};				mapObject.fromAttr = className + '.' + attr;				mapObject.toAttr = findMatchingAttribute(className, attr);				mapObject.skip = (mapObject.toAttr === '');				attrMap.push(mapObject);			}		}		importString = stream.read('\n');	}		return attrMap;}function verifyTextImportFile(importFile, delim) {	var headers = [], importString, result, stream, version = [];		stream = TextStream(importFile, 'read');	importString = stream.read('\n');	headers = importString.split(',');	if (headers.length === 2) {		version = headers[0].split(':');		if (version[1] === '1.0') {			result = {				success: true,				code: 'verifyImportSuccessful',				message: 'Verify successful for import file:<br/>' + importFile.name,				attributeMap: buildAttributeMapText(stream, delim)			};		}		else {			result = {				success: false,				code: 'invalidImportVersion',				message: 'Wrong version (' + version[1] + ') for file:<br/>' + importFile.name			}		}	}	else {		result = {			success: false,			code: 'invalidHeaderFormat',			message: 'Invalid header format for import file:<br/>' + importFile.name		}	}		stream.close();	return result;}function verifyImportFile(fileFormat, filename, importFolder) {	var importFile, result;	filename += '.' + fileFormat;	if (File.isFile(importFolder.path + filename)) {		importFile = File(importFolder.path + filename);		switch (fileFormat) {			case 'json':				result = verifyJSONImportFile(importFile);				break;			case 'csv':				result = verifyTextImportFile(importFile, ',');				break;			case 'txt':				result = verifyTextImportFile(importFile, '\t');				break;			default:				result = {					success: false,					code: 'invalidFileFormat',					message: 'Verify failed: unknown file format:<br/>' + fileFormat				};				break;		}	}	else {		result = {			success: false,			code: 'cannotFindImportFile',			message: 'Unable to find file:<br/>' + filename		};	}		return result;}function validAttributeArray(arr) {	var dataClass, valid = false;		if (arr && arr[0]) {		dataClass = ds[arr[0]];		if (dataClass) {			switch (arr.length) {				case 2:					valid = dataClass[arr[1]] !== undefined;					break;				case 3:					valid = dataClass[arr[1]].relatedDataClass[arr[2]] !== undefined;					break;			}		}	}		return valid;}function remapAttributeMap(attributeMap) {	var newMap = {};		attributeMap.forEach(		function (a) {			if (!a.skip && a.toAttr !== '') {				var arr = a.toAttr.split('.');				if (!validAttributeArray(arr)) {					throw ({						success: false,						code: 'invalidAttributeName',						message: 'Invalid attribute name:<br/>' + arr					})				}				newMap[a.fromAttr] = arr;			}		}	);		return newMap;}function conjureEntityText (className, searchArray, attrArray, valueArray, attrMap) {	var attrCount, attrKey, conjuredEntity, dataClass, searchArg, targetAttr, success = true;		dataClass = ds[className];	if (searchArray.length === 1) {		searchArg = valueArray[attrArray.indexOf(searchArray[0])]	}	else {		searchArg = {};		searchArray.forEach(			function(k) {				searchArg[k] = valueArray[attrArray.indexOf(k)]			}		);	}	conjuredEntity = dataClass(searchArg);	if (conjuredEntity === null) {		conjuredEntity = dataClass.createEntity();		if (primaryKeys.length === 1) {			conjuredEntity[searchArg] = valueArray[attrArray.indexOf(searchArray[0])];		}		else {			searchArray.forEach(				function(k) {					conjuredEntity[k] = valueArray[attrArray.indexOf(k)]				}			);		}	}		attrCount = 0;	attrArray.forEach(		function (attr) {			if (success) {				if (searchArg === attr || searchArg[attr] !== undefined) {					attrCount += 1;				}				else {					targetAttr = attrMap[className + '.' + attr];					if (targetAttr && validAttributeArray(targetAttr)) {						if (targetAttr[0] === className) {							switch (targetAttr.length) {								case 2:									conjuredEntity[targetAttr[1]] = valueArray[attrCount];									attrCount += 1;									break;								case 3:									conjuredEntity[targetAttr[1]][targetAttr[2]] = valueArray[attrCount];									attrCount += 1;									break;								default:									success = false;							}						}						else {							success = false;						}					}				}			}		}	);		if (success) {		try {			conjuredEntity.save();		} catch (e) {			success = false;		}	}		return success;}function importAllEntitiesText(attrMap, stream, delim)  {	var attrArray, importArray, importString, numberOfEntities = 0, searchArray, quote = '"';		importString = stream.read('\n');	while (importString !== '') {		importArray = importParse(importString, delim);		if (importArray[0] === CLASS_HEADER) {			className = importArray[1];			searchArray = importArray[2].split(':');			attrArray = importArray.slice(3);			importString = stream.read('\n');			importArray = importParse(importString, delim);		}		if (conjureEntityText(className, searchArray, attrArray, importArray, attrMap)) {			numberOfEntities += 1;			importString = stream.read('\n');		}		else {			throw ({				success: false,				code: 'importFailed',				message: 'Import failed for file:<br/>' + importFile.name,				numberOfEntities: numberOfEntities			});		}	}		return numberOfEntities;}function executeTextImportFile(attributeMap, importFile, delim) {	var attrMap, headers = [], importString, result, searchKeys, stream, version = [];		try {		attrMap = remapAttributeMap(attributeMap);		stream = TextStream(importFile, 'read');		importString = stream.read('\n');		headers = importString.split(',');		if (headers.length !== 2) {			throw({				code: 'invalidHeaderFormat',				message: 'Invalid header format for import file:<br/>' + importFile.name			});		}		version = headers[0].split(':');		if (version[1] !== '1.0') {			throw({				success: false,				code: 'invalidImportVersion',				message: 'Wrong version (' + version[1] + ') for file:<br/>' + importFile.name			});		}		numberOfEntities = importAllEntitiesText(attrMap, stream, delim);		stream.close();				result = {			success: true,			code: 'executeImportSuccessful',			message: 'Success! ' + numberOfEntities + ' entities imported from file:<br/>' + importFile.name,			numberOfEntities: numberOfEntities		};			} catch (e) {		result = e;		result.success = false;		if (stream) {			stream.close();		}	}		return result;}function filterJSONData(attrMap, jsonData) {	jsonData.forEach(		function(classObj) {			classObj.entities.forEach(				function(entity) {					for (attr in entity) {						var mapKey;												mapKey = classObj.className + '.' + attr;						if (entity[attr].__KEY) {							mapKey += '.ID';						}						if (attr !== '__KEY' && (!attrMap[mapKey] || attrMap[mapKey].skip)) {							delete entity[attr];						}					}				}			);		}	);}function importAllEntitiesJSON(attrMap, jsonData) {	var result = 0;		filterJSONData(attrMap, jsonData);	jsonData.forEach(		function (classObj) {			ds[classObj.className].fromArray(classObj.entities);			result += classObj.entities.length;		}	);		return result;}function executeJSONImportFile(attributeMap, importFile) {	var attrMap, importString, jsonObject, result, stream;	try {		attrMap = remapAttributeMap(attributeMap);		stream = TextStream(importFile, 'read');		importString = stream.read();		stream.close();		jsonObject = JSON.parse(importString);		if (!jsonObject.header) {			throw({				code: 'missingJSONHeader',				message: 'Missing header for import file:<br/>' + importFile.name			});		}		if (jsonObject.header.version !== '1.0') {			throw({				success: false,				code: 'invalidImportVersion',				message: 'Wrong version (' + jsonObject.header.version + ') for file:<br/>' + importFile.name			});		}				numberOfEntities = importAllEntitiesJSON(attrMap, jsonObject.data);				result = {			success: true,			code: 'executeImportSuccessful',			message: 'Success! ' + numberOfEntities + ' entities imported from file:<br/>' + importFile.name,			numberOfEntities: numberOfEntities		};			} catch (e) {		result = e;		result.success = false;		if (stream) {			stream.close();		}	}		return result;}function executeImportFile(param, importFolder) {	var filename, importFile, result;	filename = param.filename + '.' + param.format;	if (File.isFile(importFolder.path + filename)) {		importFile = File(importFolder.path + filename);		switch (param.format) {			case 'json':				result = executeJSONImportFile(param.attributeMap, importFile);				break;			case 'csv':				result = executeTextImportFile(param.attributeMap, importFile, ',');				break;			case 'txt':				result = executeTextImportFile(param.attributeMap, importFile, '\t');				break;			default:				result = {					success: false,					code: 'invalidFileFormat',					message: 'Import failed: unknown file format:<br/>' + fileFormat				};				break;		}	}	else {		result = {			success: false,			code: 'cannotFindImportFile',			message: 'Unable to find file:<br/>' + filename		};	}		return result;}function importVerifyFunction(param) {	var importFolder, result;	importFolder = Folder(ds.getModelFolder().path + 'ExportData');	if (importFolder.create()) {		result = verifyImportFile(param.format, param.filename, importFolder);	}	else {		result = {			success: false,			code: 'cannotCreateExportFolder',			message: 'Unable to find folder for export data'		};	}		return result;};function importExecuteFunction(param) {	var importFolder, result;	importFolder = Folder(ds.getModelFolder().path + 'ExportData');	if (importFolder.create()) {		result = executeImportFile(param, importFolder);	}	else {		result = {			success: false,			code: 'cannotCreateExportFolder',			message: 'Unable to find folder for export data'		};	}		return result;};function exportPreviewFunction(param) {	var resultString;		switch (param.format) {		case 'json':			resultString = exportJSONPreview(param);			break;					case 'csv':			resultString = exportCSVPreview(param);			break;				case 'txt':			resultString = exportTextPreview(param);			break;	}		return (resultString);}function exportClassesFunction(param) {	var resultObject;		switch (param.format) {		case 'json':			resultObject = exportJSON(param);			break;					case 'csv':			resultObject = exportCSV(param);			break;				case 'txt':			resultObject = exportText(param);			break;	}		return (resultObject);}function getJSONHeader(param) {	var header = {};		header.version = '1.0';	header.classes = param.classes;	header.format = param.format;	header.attr = {};	header.search = {};	param.classes.forEach(		function (className) {			if (header.attr[className] === undefined) {				header.attr[className] = [];			}			for (attr in ds[className].attributes) {				header.attr[className].push(attr);			}			header.search[className] = ['ID'];		}	);		return header;}function getJSONClass(className, preview) {	var result, dataClass = ds[className];		return {		className: className, 		entities: dataClass.toArray('', '', true, 0, preview ? PREVIEW_SIZE : dataClass.length)	};}function getHeaderString(className, delim) {	var attr, dataClass, quote = '"', s;		s = quote + CLASS_HEADER + quote + delim + quote + className + quote + delim + quote + 'ID' + quote + delim;	dataClass = ds[className];	for (attr in dataClass.attributes) {		if (dataClass[attr].kind === 'storage') {			s +=  quote + attr + quote + delim;		}		if (dataClass[attr].kind === 'relatedEntity') {			s +=  quote + attr + '.ID' + quote + delim;		}		if (dataClass[attr].kind === 'alias') {			s +=  quote + attr + quote + delim;		}	}		return (s.substr(0,s.length - 1) + '\n');}function getEntityString(entity, delim) {	var attr, dataClass, quote = '"', s = '';		dataClass = entity.getDataClass();	for (attr in dataClass.attributes) {		if (dataClass[attr].kind === 'storage') {			s +=  quote + entity[attr].toString() + quote + delim;		}		if (dataClass[attr].kind === 'relatedEntity') {			s +=  quote + entity[attr].getKey().toString() + quote + delim;		}		if (dataClass[attr].kind === 'alias') {			s +=  quote + entity[attr].toString() + quote + delim;		}	}	return (s.substr(0, s.length - 1) + '\n');}function preparePreviewString(classNames, delim) {	var entities, i, r = '';	r = 'version:1.0' + delim + 'format:csv' + delim + 'classes:' + classNames.join('/') + '\n';	classNames.forEach(		function (className) {			r += getHeaderString(className, delim);			entities = ds[className].all();			for (i = 0; i < (entities.length < PREVIEW_SIZE ? entities.length : PREVIEW_SIZE); i += 1) {				r += getEntityString(entities[i], delim);			}		}	);		return r;}function prepareExportString(classNames, delim) {	var entities, i, r = '';	r = 'version:1.0,classes:' + classNames.join('/') + '\n';	classNames.forEach(		function (className) {			r += getHeaderString(className, delim);			entities = ds[className].all();			entities.forEach(				function (entity) {					r += getEntityString(entity, delim);				}			);		}	);		return r;}function exportJSONPreview(param) {	var result = {};		result.header = getJSONHeader(param);	result.data = [];	param.classes.forEach(		function (c) {			result.data.push(getJSONClass(c, true));		}	);		return JSON.stringify(result);}function exportCSVPreview(param) {	return preparePreviewString(param.classes, ',');}function exportTextPreview(param) {	return preparePreviewString(param.classes, '\t');}function exportStringToFile(exportString, filename, fileFormat) {	var exportFile, exportFolder, stream, result = {};	if (!filename) {		filename = generateUUID();	}	filename += '.' + fileFormat;		exportFolder = Folder(ds.getModelFolder().path + 'ExportData');	if (exportFolder.create()) {		exportFile = File(exportFolder.path + filename);		if (File.isFile(exportFolder.path + filename)) {			exportFile.remove();		}		if (exportFile.create()) {			stream = TextStream(exportFile, 'write');			stream.write(exportString);			stream.close();			result = {				success: true,				code: 'exportSuccessful',				message: exportString.length + ' bytes exported to:<br/>' + filename			};		}		else {			result = {				success: false,				code: 'cannotCreateExportFile',				message: 'Unable to create file:<br/>' + filename			};		}	}	else {		result = {			success: false,			code: 'cannotCreateExportFolder',			message: 'Unable to create folder for export data'		};	}		return result;}function exportJSON(param) {	var result = {};	result.header = getJSONHeader(param);	result.data = [];	param.classes.forEach(		function (c) {			result.data.push(getJSONClass(c));		}	);		return exportStringToFile(JSON.stringify(result), param.filename, param.format);}function exportCSV(param) {	var exportString;		exportString = prepareExportString(param.classes, ',');	return exportStringToFile(exportString, param.filename, param.format);}function exportText(param) {	var exportString;		exportString = prepareExportString(param.classes, '\t');	return exportStringToFile(exportString, param.filename, param.format);}